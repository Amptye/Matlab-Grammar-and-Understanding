%% 清空工作区和命令行窗口
clear; % 清空工作区
clc; % 清空命令行窗口
% 可直接在命令行窗口输入代码文件名（不带后缀）运行代码文件
% 获取关键字的完整列表：命令行输入 iskeyword
% 特殊变量：ans、pi、inf/-inf（1/0 = inf）

%% 注释
% 两个百分号（%%） 用于定义 代码节（Code Section），也称为 代码单元（Cell）。它的主要功能是将脚本文件（.m 文件）分成多个独立的部分，便于分段执行、调试和文档管理。
%{
两个百分号（%%）作用：
划分代码节：在 .m 文件中，%% 会创建一个 分节符，将代码分成多个逻辑块。
单独运行某个节：在 MATLAB 编辑器中，光标放在某个节内，按 Ctrl + Enter（Windows/Linux） 或 Command + Enter（macOS），可以仅执行当前节，而不会运行整个脚本。适用于分段调试，避免重复运行整个代码。
添加节标题：在 %% 后面可以写 节标题，方便代码导航，在 MATLAB 编辑器的 节导航栏 中可以直接跳转到不同节
发布（Publish）代码时生成文档
代码折叠：在 MATLAB 编辑器中，可以 折叠节（点击 - 号），使代码更整洁
%}

% 这是一个单行注释

%{
这是多行注释，
可以写多行文字，
这些内容不会被执行。
"%{" 和 "%}" 必须单独成行，且前后不能有其他字符（包括空格）。
选中代码后按 Ctrl + R（注释），Ctrl + T（取消注释）。
%}

% 函数开头的注释会作为 帮助文档，通过 help 函数名 显示：
function y = square(x)
% SQUARE 计算输入值的平方
%   用法: y = square(x)
%   输入: x (数值)
%   输出: y = x^2
    y = x^2;
end
%{
在命令窗口输入 help square 会显示注释内容：
>> help square
  SQUARE 计算输入值的平方
    用法: y = square(x)
    输入: x (数值)
    输出: y = x^2
%}

%% 字符与字符串
s = 'a';
abs(s); % ASCII码，ans = 97
char(65); % ASCII码，ans = 'A'
num2str(65); % 数字转字符数组，ans = '65'
string(65); % 数字转字符串，ans = "65"

str = 'I Love MATLAB & Machine Learning.'; % 单引号的串是 “字符数组”，类型是 “char”，不支持多行文本，大小为 1x[字符串长度]
str1 = ['A', 'B']; % 拼接成 'AB'

str2 = "abcd"; % 双引号表示字符串，类型是 “string”，支持多行文本、加号拼接，大小为 1x1
str3 = "Hello"; % 字符串标量
str4 = "Line 1\nLine 2"; % 支持转义字符（显示为两行）
str5 = "Value: " + 42; % 自动转换数值为字符串"42"，合成一个字符串
str6 = "string + " + 'abc'; % 字符数组转为字符串，合成一个字符串

char("Hello"); % 返回 'Hello'
string('Hello'); % 返回 "Hello"

char(42); % 返回ASCII码对应的字符
abs('42'); % 返回字符数组中每个字符的ASCII码，ans = 52 50（只接受 char 类型参数）
num2str(42); % 返回 '42'
string(42); % 返回 "42"
str2num('42'); % 返回 42（也可以用 str2double）
str2num("42"); % 返回 42（也可以用 str2double）
int32('42'); % 返回字符数组中每个字符的ASCII码，ans = 52 50（也可用 int16、int64，只接受 char 类型参数）
double('42'); % 返回字符数组中每个字符的ASCII码，ans = 52 50
double("42"); % 返回 42
%{
                      num
                  //\     /\\
                 //         \\
                //      abs()\\         \
               //      int32()\\char()   } 都是与 “字符” 之间的转换（ASCII码）
              //       double()\\       /
     string()//double()         \\
            //str2num()          \\
           //str2double()         \\
          //              str2num()\\num2str() \ 都包含了 “str”，与 “字符数组” 相关
         //             str2double()\\         / （使得看起来像 “字符串”）
        //                           \\
      \//           char()            \\/
string --------------------------------> char
       <--------------------------------
                   string()
%}

length(str); % ans = 33
length(str2); % ans = 1
length(num2str(65)); % ans = 2
'abc'+'c'; % 同 'abc' + 'ccc'（广播原则），结果为数组，ans = 196 197 198

%% 矩阵
A = [1 2 3;4 5 2;3 2 7]; % 行之间用分号或回车，列之间用空格或逗号
A1 = [1,2,3
    4,5,6
    7,8,9];
B = A'; % 转置
C = A(:); % 将矩阵各列排成一个列向量（从上到下遍历一列，再遍历后面的列）（本质是遍历矩阵，详见下面的 “注意”）
D = inv(A); % 求逆
E = zeros(10,5,4,3); % 创建一个多维全零数组，例如zeros(size1, size2, ..., sizeN)，或复制现有数组的尺寸：zeros(size(existingArray));
E1 = zeros(5); % 参数为一个时，创建方阵
%{
注意：多维矩阵的遍历是先将一层低维的遍历完，再沿着高纬的方向遍历下一层低维
如：A[2,3,4,5]为四维数组（四维矩阵），遍历顺序为：A[1,1,1,1]，A[2,1,1,1]，A[1,2,1,1]，A[2,2,1,1]，...，A[2,3,4,1]，A[1,1,1,2]，...，A[2,3,4,5]
所以二维数组的遍历看起来是 “列优先的”。
因为 “行数” 写在 “列数” 前面，所以 “行” 成了 “列” 的 “低维”，
只有把一列的每行都遍历完，才能遍历下一列。
而要 “行优先” 的话，就得把 “行数” 写在 “列数” 后面。

或者可以说，多维矩阵 “不存在” “行” 的概念，只有 “第一维”、“第二维” 等概念，
就类似于 “(y,x,z)” 这样的坐标，第一维度为 y轴，第二维度为 x轴，第三维度为 z轴
按人脑的逻辑，对于A(1,2,3)，应该是：
先在第一列找到需要的点（就是第一维的一个点，零维），就是第一列的关注点，
再在第一面找到需要的列（就是第二维的一个列，一维），将第一列的关注点平移到该列，得到第一面的关注点，
再在第一体找到需要的面（就是第三维的一个面，二维），将第一面的关注点平移到该面，以此类推。

当使用 “线性索引” 或 reshape 时，MATLAB 会临时将多维矩阵视为 “一维” 序列，顺序与 “遍历” 相同

MATLAB中，一维数组都是以 1xN 的二维矩阵形式存在的，没有纯粹的纯一维数组。
可使用 size 函数：size([1 2 3])返回 [1,3]（行向量），size([1; 2; 3])返回 [3, 1]（列向量）
但 MATLAB 对向量的操作有特殊优化：
数学运算：行/列向量在加减、点乘等操作中会被自动识别为向量，无需严格匹配维度。
索引简化：单下标索引（vec(i)）对行/列向量通用，无需指定行或列。
可使用 isrow/iscolumn 判断方向
%}

%% 矩阵的创建
% 直接输入法：用中括号作为标识符，行之间用分号或回车，列之间用空格或逗号
A = [1 2 3;4 5 2;3 2 7];
A1 = [1,2,3
    4,5,6
    7,8,9];
A2 = 1:5; % 表示 “从 1 到 5，每次间隔 1，即 1 2 3 4 5”
A3 = 1:0.1:2; % 表示 “从 1 到 2，每次间隔 0.1”
f(1)=1; % 可以不用初始化
f(10)=2; % 创建为一个 1xN 的数组，未初始化的部分用 0 填充

% 函数创建法（参数为一个时，都是创建方阵；参数为多个时，按参数个数创建多维矩阵）
% 第一组函数：zeros、ones、eye，分别创建：全为 0 的矩阵、全为 1 的矩阵、单位矩阵
b = zeros(100); % 100x100 的方阵
c = zeros(100,99); % 100x99

% 第二组函数：rand、randi、randn，分别创建：均匀分布的随机数、均匀分布的随机整数、标准正态分布的随机数
% rand 函数默认生成 [0, 1) 范围内的均匀分布随机数（即包含 0 但不包含 1）
d = rand(5); % 5x5 的方阵
d = rand(5,6); % 5x6 的矩阵
% randi([imin,imax],sz)，中括号内为上界和下界，或 randi(imax,sz)，下界默认为 1
e = randi([1,6],6); % 6x6 的方阵
e = randi([1,6],1,20); % 1x20 的矩阵（一维数组）
% randn()
f = randn(5);
f = randn(5,6);

% 导入本地文件中的数据
% MATLAB可读取本地的文件，支持的常见格式如下：
% txt、.dat或.csv（适用于带分隔符的文本文件）
% xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx或.ods（适用于电子表格文件）
% 在 “主页” 中 点击 “导入数据” 选项，导入数据会比实际数据少掉 “第一行”（因为默认第一行为名称）

%% 矩阵元素的修改和删除
A = [1 2 3 4; 2:5; 3:6];
A(2,3) = 10;
A(2,:) = 10; % 第 2 行全部替换
A([1,3],[1,2]) = 0; % A(rows,cols)，修改所有 “交汇点”（“子矩阵”）
% 注意：以上都是修改 “子矩阵”

% 线性索引
% 按遍历顺序索引
A(5) = 0;

% 超越边界
% 会自动拓展，用 0 填充，并永久改变矩阵大小
A(5,6) = 888;
A(5,6) = 0;
% 注意：索引值可以超出维度，不为 1 时会改变矩阵维度
A(2,3,2) = 666;

% 删除（会改变矩阵大小）
A(1,:) = []; % 删除第 1 行，会改变矩阵大小
A(:,1) = []; % 删除第 1 列，会改变矩阵大小
A(:,[1,end]) = []; % 删除第 1 列 “和” 最后一列，end 代表 “最后” 的索引
A(:,1:end) = []; % 删除第 1 列 “到” 最后一列（即全部删除）

% 删除单个元素（不能直接删除，必须用线性索引，矩阵会 “按遍历顺序” 变成一个 “行向量”，然后删除）
A(1) = [];
%{
注意：对于多维数组的访问和删除（维度数为 n，索引值的维度数为 m，其中 m 中可能包含冒号索引）
（1）m = n，正常访问，要删除的东西维度数 d 需满足 d >= n-1，否则会报错（空赋值只能具有一个非冒号索引）
（2）1 < m < n，会先将多余的维度在第 m 维度 “按遍历顺序” 拼接，使得拼接后维度为 n' = m，然后访问或删除（访问不会修改原矩阵的维度数，删除会修改）
    “拼接过程” 其实就是 reshape(A,dim_1,dim_2,...,dim_{m-1},dim_m*dim_{m+1}*...*dim_n)
（3）m = 1，即线性索引，“按遍历顺序” 访问，删除时，矩阵会 “按遍历顺序” 变成一个 “行向量”，然后删除（比较特殊，不是变成 “列向量”）
    其实 “遍历顺序” 就是将 1 以上的维度拼接到第 1 维度，然后遍历
%}

%% 矩阵的拼接、重构、重排
A = zeros(3);
B = ones(3);
% 矩阵的拼接
% 横向拼接：A 和 B 的行数相同，那么：
C = [A,B];
C = [A B];
C = cat(2,A,B);
% 纵向拼接：A 和 B 的列数相同，那么：
D = [A;B];
D = [A
    B];
D = cat(1,A,B);
%{
注意：cat(dim, A, B, ...)，其中 dim 表示 “在哪个维度拼接”（可参考 “矩阵”小节 “注意” 的第二段）
dim = 1：在第一维度拼接，即拼接成列（y轴，纵向拼接）（即矩阵的第一个维度叠加）
dim = 2：在第二维度拼接，即拼接成面（x轴，横向拼接）（即矩阵的第二个维度叠加）
dim = 3：在第三维度拼接，即拼接成体（z轴，前后拼接）（即矩阵的第三个维度叠加）
%}

% 矩阵的重构重排
% reshape()：更改矩阵的形状，reshape(A,m,n) 或者 reshape(A,[m,n])、reshape(A,new_size)，
% 新维度 (new_size) 的元素总数必须与原数组相同，
% 元素按 “遍历顺序” 重新填充（线性索引顺序不变）
A = 1:6; % 行向量 [1 2 3 4 5 6]
B = reshape(A, 2, 3); % 2×3 矩阵
C = reshape(A, [], 2); % []表示自动计算，以保持元素总数不变（但是要能算出整数，即另一个数要能整除总数）

% sort()：对向量或者矩阵进行排序，sort(A,dim)，默认 dim = 1，在最后面加一个输入参数 “descend” 变成降序排列（默认 ascend，表示升序）
%   dim = 1：沿着行方向（第一维度，y轴，从上至下）对矩阵的每一列排序
%   dim = 2：沿着列方向（第二维度，x轴，从左至右）对矩阵的每一行排序
% 支持复数（按模排序）、字符串（按字典序）。
A = [3 1 4; 2 5 0];
B = sort(A, 2); % B = [1 3 4; 0 2 5]

% sortrows()：基于矩阵的某一列对矩阵进行排序，同一行的元素不会改变。（即将矩阵视为一个 “列向量”）
% sortrows(A,cols)，cols 指定排序依据的列号（默认为第一列，可为多列），在最后面加一个输入参数 “descend” 变成降序排列（默认 ascend，表示升序）
A = [3, 'A'; 1, 'B'; 2, 'C'];
B = sortrows(A, 1); % 按第1列排序
C = sortrows(A, [2, 1]);

%% 矩阵的运算
% 函数运算
%{
sum：求和函数
prod：求乘积函数（product）
cumsum：计算累积和（cumulative sum）
diff：计算差分（difference）
mean：计算平均值
median：计算中位数
mode：计算众数
var：计算方差（variance）
std：计算标准差（standard deviation）
min：求最小值（minimum value）
max：求最大值（maximum value）
%}
A = randi(10,3,4);
% sum(A,dim)，dim 为沿哪个维度求和，默认为第一个非单一维度，
% dim="all"时，求全部元素的和，= sum(sum(A)) = sum(A(:))
sum(A,1);
sum(A, "all");

% prod(A, dim)，沿指定维度求积
prod(A,1);
prod(A,"all");

% cumsum(A, dim)，返回沿维度的累积和（逐步累加）
cumsum([1 2 3]); % 返回 [1 3 6]

% diff(A, n, dim)，计算相邻元素的差分，
% n 为差分阶数，即运行差分函数的次数（默认为1，可写为[]）
diff([1 4 7 9]); % 返回 [3 3 2]
diff([1 2; 4 5], 1, 2); % 行内差分，返回 [1; 1]
diff(1:5,2); % = diff(diff(1:5))

% mean(A, dim)，计算算术平均值
mean([2 4 6]); % 返回 4
mean(A,"all");
mean([1 NaN 3], 'omitnan') % 忽略缺失数据，返回 2

% median(A, dim)，返回中位数值（50%分位数）
median([1 3 5 7]); % 返回 4（偶数个取平均）
median(A,"all");

% mode(A, dim)，找出出现频率最高的值
mode([1 2 2 3]); % 返回 2
mode(A,"all");

% var(A, w, dim)，计算方差（默认无偏估计，分母为 n-1），
% w 为权重（0:无偏，1:有偏）
var([1 2 3]); % 返回 1（样本方差）

% std(A, w, dim)，方差的正平方根，衡量数据离散程度，
% w 同 var
std([1 2 3]); % 返回 1

% [m, idx] = min(A, [], dim)
% [m, idx] = max(A, [], dim)
% idx 为索引位置，dim 默认为第一个非单一维度，[] 可选
% dim 可为向量，返回向量所指定的维度上的最小值
% （即沿着多维空间取最值，而不是单个维度的一维直线，等同于依次沿向量中所指定的维度，进行多次 min 或 max）
% min(A,B)，比较两个数组 A 和 B 的对应元素，并返回一个与输入数组大小相同的新数组，
% 其中每个元素是 A 和 B 对应位置的最小值，max 同理，但 A 和 B 的维度必须相同或兼容（满足广播规则）（可以都为标量）
% 若 A 或 B 包含 NaN，会忽略 NaN 并返回非 NaN 值（若两者均为 NaN，则返回 NaN）。
[min_val, pos] = min([5 2 8]); % min_val = 2，pos = 2
min(A,[],[1 2]); % 沿着 “第一维度” 和 “第二维度” 构成的 “面” 取最值
min(3, 5); % 返回 3
min(1:5,2:6);
%{
注意：广播原则：是一种允许不同维度的数组进行逐元素运算的机制。
它通过自动 “扩展” 较小数组的 “维度”，使其与较大数组的 “维度兼容”，从而无需显式复制数据即可完成运算。
“关键条件”：两个数组在 “每个维度” 上的大小必须满足以下之一：
    相等（如 A 是 3×4，B 是 3×4）
    其中一个为 1（如 A 是 3×4，B 是 1×4 或 3×1）
    其中一个维度不存在（即较小数组的维度数较少，其实也就是该维度大小为 1）
广播的步骤：
    对齐维度：从最后一个维度开始向前匹配。
    扩展大小为 1 的维度：将较小数组的维度从 1 复制到与较大数组相同。
    执行逐元素运算：如 +, .*, ./, max, min 等。
示例：
A = [1; 2; 3];  % 3×1
B = [4 1 2];    % 1×3
min(A, B)       % 返回 3×3 矩阵：
                % [1 1 1; 2 1 2; 3 1 2]
其中，先将 A 扩充至 3x3，再将 B 扩充至 3x3
%}

%{
注意：vecdim 为 dim 组成的向量，
dim 是沿着 “某个维度”，即沿着单个维度的一维直线，即在该维度的直线内操作
而 vecdim 表示沿着 “多个维度”，即沿着多维空间，即在该多维空间内操作（不能进行 “线性操作”，如排序、拼接、差分、累加等）
%}

% 算术运算
% 加减乘除（左除、右除）
% 加减服从广播原则
% 乘法：* 和 .* 分别表示 矩阵相乘 和 矩阵中对应元素相乘
% 除法：/（右除）、\（左除）和 ./（矩阵中对应元素相除）
% 乘方：^（乘方，左边是方阵，右边是标量）和 .^（矩阵中对应元素乘方）
% 转置：'（复数矩阵转置时，复数会变成共轭复数）和 .'（复数矩阵转置时，保持原来的复数）
A = [1 2 3+i; 2-i 2 3];
A';
A.';

% 关系运算
% 在对应元素之间运算
% ==（等于）、~=（不等于）、>（大于）、>=（大于等于）、<（小于）、<=（小于等于）
% 返回逻辑值 0 或 1 的矩阵

%% 逻辑基础
% 逻辑运算符
%{
在矩阵对应元素之间运算
会将非零数值视为逻辑 1，将数值零视为逻辑 0 进行运算
逻辑与：and()、&
逻辑或：or()、|
逻辑非：not()、~
逻辑异或：xor()
优先级：关系运算符 > 逻辑运算符
其他：&& 和 || 只能对标量进行逻辑运算，且具有短路功能，可以提高运行效率
%}
A = randi([-3,3],2,4);
B = randi([-3,3],1,4);
C = randi([-3,3],1,4);
A & B;
A | B;
~A;
xor(3,4); % 返回 0，= xor(1,1)
A & B & C;
(-1<=A) & (A<2);

% 逻辑运算函数
%{
all()：判断数组元素是否全为 “非零值”（可指定沿什么维度判断）
any()：判断数组元素是否存在至少一个 “非零值”（可指定沿什么维度判断）
find()：查找数组中的 “非零元素”，并返回其索引
find(X) 返回一个包含数组 X 中每个非零元素的 “线性索引” 的向量。
    如果 X 为 “向量”，则 find 返回方向与 X 相同的向量。
    如果 X 为 “多维数组”，则 find 返回由结果的线性索引组成的 “列向量”。
find(X,n) 返回与 X 中的非零元素对应的 “前 n 个” 索引。
find(X,n,direction)，direction 为 'last'时，查找与 X 中的非零元素对应的 “最后” n 个索引。direction 的默认值为 'first'，即查找与非零元素对应的前 n 个索引。
[row,col] = find(___) 使用上述语法中的任何输入参量返回数组 X 中每个非零元素的行和列下标。
[row,col,v] = find(___) 还返回包含 X 的非零元素的向量 v。
%}
all(A);
any(A);
any(A,"all");
any(A,[1,2]);
any(randi([-2,2],2,2,2),[1,2]);
any(A<2,2); % A<2 也是一个矩阵
find(A,5,'last');
[row,col] = find(A);
[row,col,v] = find(A);

%% 结构基础
% 条件结构
% if-elseif-else-end 语句，elseif 关键字中间不能加空格，if 和 end 不能省略
score = 87;
if (score >= 90) && (score <= 100)
    res = 1;
elseif (score >= 80) && (score < 90)
    res = 2;
elseif (score >= 60) && (score < 80)
    res = 3;
elseif (score >= 0) && (score < 60)
    res = 4;
else
    res = 0;
end
disp(res); % display
% if 后面跟矩阵时，只有矩阵全为非零元素，才判为真
if [1,2;0,3]
    disp('yes');
elseif [1,2;3,4]
    disp('ok');
else disp('no');
end

% switch-case-otherwise-end 语句，switch 和 end 不能省略
% switch 后面跟 “开关表达式”，即 “判断对象”
% 开关表达式的计算结果必须是一个数值标量，或者是一个字符向量/字符串，不能是向量或者矩阵
season = randi([1,4]);
switch season
    case 1
        disp('春季')
    case 2
        disp('夏季')
    case 3
        disp('秋季')
    case 4
        disp('冬季')
    otherwise % 也可不写 otherwise
end

% 循环结构
% for-end 语句（for 循环）
%{
for 循环变量 = 向量或者矩阵
    循环体
end
循环变量：会在每次循环迭代中从向量或矩阵中取出 “一列” 的值。
类似于 C++ 和 Java 中基于范围的循环：for(int i:array){}
类似于 Python 中基于范围的循环：for num in nums:...
%}
for i = 1:5
    disp(i);
end
for i = randi([-3,3],2,3)
    disp(i);
end

% while-end 语句（while 循环）
%{
while 表达式
    循环体
end
允许我们在不知道具体循环次数的情况下执行循环体
一个无限循环，在命令行窗口中按下快捷键 Ctrl + C 来中断程序的运行
while 后面的表达式的计算结果不一定非得是逻辑值 0 或 1
%}

% break 和 continue
% break 关键字用于终止执行循环
% continue 关键字用于跳过循环的当前迭代，然后继续下一次迭代

%% 自定义函数
% m文件定义函数
%{
Matlab函数的基本结构：
function[输出形参表：output1,...,outputn] = 函数名(输入形参表：input1,...inputn)
注释说明部分
函数体代码部分
end
其中，输出形参为单个时，不需要中括号，无输出时，不需要等号，无输入时，不需要小括号
%}
%{
函数调用
定义完的函数保存为 “同函数名” 的 m文件，放置在 Matlab 的当前路径之下，
然后就和使用 Matlab 自带的函数一样，直接在命令窗口或程序代码中使用该函数就是调用它了
函数调用的一般格式为：
[输出实参表] = 函数名(输入实参表)
%}
%{
函数中遇到 return 语句时，将退出函数体
函数体里面也可以定义函数（子函数），子函数在主函数体内的 “位置可以任意”，不影响使用，
子函数只能被主函数以及其他位于同一主函数体内的子函数调用
在调用函数时，Matlab 用两个永久变量 nargin 和 nargout 分别记录调用该函数时的输入实参和输出实参的个数
%}

% 匿名函数
% 匿名函数是不存储在程序文件中，数据类型是 function_handle 的变量相关的函数，
% 不用编写为单独的 m文件，效率比更高。
%{
基本格式：
f = @{输入参数列表} 函数表达式
%}
f = @(x,y) x.^2 + y.^2;
f1 = @(a,b) @(x) a*x+b;
f2 = @(a) @(x)exp(x)+x^a+x^(sqrt(x))-100;
fzero(f2(1),4); % fzero() 求函数=0的根
A = 1:0.1:2;
x = @(a) fzero(f2(a),4);
X = @(A) arrayfun(x,A); % arrayfun(func,A) 将函数 func 应用于 A 的元素，一次一个元素
Y = X(A);

%% 特殊函数
% 特殊函数是一组在实际应用中经常出现的著名数学函数。可以用它们来计算贝塞尔函数、beta 函数、gamma 函数、误差函数、椭圆积分等
% 函数的详细信息：NIST Digital Library of Mathematical Functions
% 也可直接在 “帮助中心” 搜索 “特殊函数”

%% 常用函数
%{
在矩阵中各元素运算
abs：求绝对值，也可用来计算复数的模长
mod：mod(x,y)可以计算 x 除以 y 后的余数，结果与 y 同号，结果为 m = x - floor(x./y).*y（floor 为 向下取整）
rem：rem(x,y)可以计算 x 除以 y 后的余数，结果与 x 同号（remain），结果为 r = x - y.*fix(x./y)（fix 为 向零取整）
sqrt：sqrt(a)可以计算 a 的平方根，如果 a 为负数则返回复数结果，== a^(1/2)
exp：可以计算以 e 的底的指数
log：用来计算以 e 为底的对数
log2/log10：分别用来计算以 2 和 10 为底的对数
%}
abs(-3+4i);
mod(5,3);
mod(5,-3);
rem(5,-3);
sqrt(1:9);
% format(style) 将输出显示格式更改为 style 指定的格式
% 例如，format("shortG") 以总共 5 位的紧凑形式显示数值
% 数值格式仅影响数字显示在的显示方式，而不是 MATLAB 计算或保存它们的方式
% 按名称指定样式时，可以使用 不带括号 或 引号 的 “命令形式”
% 当 请求输出 时或 传递变量 作为输入时，无法使用 “命令形式”
format long % 将输出格式改成 “长浮点数” 的格式
format shortG
fmt = format("short"); % 默认格式，显示 5 位有效数字（4 位小数）
format(fmt)
exp(2);
log(exp(2));

%{
round：真正意义上的四舍五入函数（将结果四舍五入为最近的整数，如果为 0.5，则会朝着 “偏离零” 的方向调整）
round 函数还有第二种用法，可以输入第二个参数：
round(X,N) 可以将 X 在第 N 位数四舍五入，分为下面三种情况：
    1) N>0：四舍五入到小数点右侧的第 N 位数
    2) N=0：四舍五入到最接近的整数
    3) N<0：四舍五入到小数点左侧的第 N 位数
%}
round(2.5);
round(2.445566,3);
round(445566.7788,-3);

% 三角学函数
% 可在 “帮助中心” 中搜索
sin(2*pi); % 以 弧度 为单位
sind(180); % 以 度 为单位

% isempty 函数
% 如果 A 为空数组 []，isempty(A) 返回逻辑值 1，否则返回逻辑值 0.
% length(A)==0 的结果与 isempty(A) 的结果一样，但后者运行效率更高
isempty(find([0 0 0]));

% ismember 函数
% 如果 A 中某位置的数据能在 B 中找到，ismember(A,B) 将返回一个在该位置包含逻辑值 1 的数组。数组中的其他位置将包含逻辑值 0
% ismember(A,B,"rows") 将 A 和 B 中的每一行视为一个实体，当 A 中的行也存在于 B 中时，将返回包含逻辑值 1 的列向量
ismember(1:5,3:9);

% meshgrid 函数
% [X,Y] = meshgrid(x,y) 基于向量 x 和 y 中包含的坐标返回二维 “网格” 坐标。
% X 是一个矩阵，每一行是 x 的一个副本；Y 也是一个矩阵，每一列是 y 的一个副本。
% 坐标 (X,Y) 表示的网格有 length(y) 个行和 length(x) 个列。
% 即：X 是网格所有点的 “横坐标”，Y 是网格所有点的 “纵坐标”
meshgrid(0:3,0:4);
meshgrid(0:3); % meshgrid(x) = meshgrid(x,x)

% rng 函数
% 可用来设置随机数种子，这样能生成可重复的随机数
% 使用随机数生成函数之前，使用 rng(seed) 命令设置随机数种子，这样能保证生成的随机数被固定下来。
% 每次重新启动 MATLAB 会话时，随机数生成器均复位到相同的状态，这样使用生成随机数的命令会返回相同的结果
% 可以使用 rng('shuffle') 命令，它可以根据当前的时间使用不同的种子重新设定生成器的种子，这样能避免重复生成相同的随机数
% rng("default") 使用默认算法和种子初始化 MATLAB 随机数生成器。出厂默认设置是种子为 0 的梅森旋转生成器。
% rng 函数控制全局流
%{
rng(seed) 使用当前生成器算法指定随机数生成器的种子。
    将 seed 指定为非负整数，如 rng(1)，用该种子初始化随机数生成器。
    将 seed 指定为 "shuffle"，以根据当前时间初始化生成器种子。
rng(seed,generator) 还指定随机数生成器要使用的算法。
    例如，rng(2,"philox") 使用种子 2 初始化 Philox 4×32 生成器。
rng(generator) 指定种子为 0 的随机数生成器要使用的算法。
    此语法等效于 rng(0,generator)。

%}
t = rng(3);
randi(10,3);

%% 二维图形绘制
% 基本绘图函数
%{
plot 函数
plot(X,Y) 创建 Y 中数据对 X 中对应值的二维线图。
要绘制由线段连接的一组坐标，请将 X 和 Y 指定为 相同长度 的向量。
要在同一组坐标区上绘制多组坐标，请将 X 或 Y 中的至少一个指定为矩阵。
如果 Y 包含复数，虚部将被忽略。
plot(X,Y,LineSpec) 使用指定的线型、标记和颜色创建绘图。

X、Y 为矩阵时，plot(X,Y) 会将 X 和 Y 的 “每一列” 作为一组独立的曲线绘制。
因此，X 和 Y 必须具有相同的 “列数”，或者一方为向量时自动广播
如果输入是行向量（1×N），会被视为单列数据（等效于 N×1 列向量）
如果一个是向量，一个是矩阵，向量的长度必须与矩阵的 “维度之一” 相匹配
    与 “行数” 相匹配时，直接取 “列”
    与 “列数” 相匹配时，会先将矩阵转置

plot(X1,Y1,...,Xn,Yn) 在同一组坐标轴上绘制多对 x 和 y 坐标。此语法可替代将坐标指定为矩阵的形式。

plot(Y) 绘制 Y 对一组隐式 x 坐标的图。
如果 Y 是向量，则 x 坐标范围从 1 到 length(Y)。
如果 Y 是矩阵，则对于 Y 中的每个列，图中包含一个对应的行。x 坐标的范围是从 1 到 Y 的行数。
如果 Y 包含复数，MATLAB 绘制 Y 的虚部对 Y 的实部的图。如果同时指定了 X 和 Y，虚部将被忽略。
%}
x = 1:9;
y = x.^2;
plot(x);
t = 0:0.01:2*pi;
t = t.';
x=[t,t,t];
y = [sin(t),sin(2*t),sin(0.5*t)];
plot(x,y);
% linspace 函数
% linspace(x1,x2) 返回 x1 和 x2 之间等间距点的行向量，默认情况下，产生 100 个点
% linspace(x1,x2,n) 生成 n 个点，间距为 (x2-x1)/(n-1)
x1 = linspace(0,2*pi,10);
x2 = linspace(0,2*pi,100);
x3 = linspace(0,2*pi,200);
y1 = sin(x1);
y2 = sin(x2)+2;
y3 = sin(x3)+4;
plot(x1,y1,x2,y2,x3,y3);
plot(x1,y1,':g',x2,y2,x3,y3); % 绿色虚线

%{
fplot 函数
fplot(f) 在默认区间 [-5 5]（对于 x）绘制由函数 y = f(x) 定义的曲线。
fplot(f,xinterval) 将在指定区间绘图。将区间指定为 [xmin xmax] 形式的二元素向量。
fplot(funx,funy) 在默认区间 [-5 5]（对于 t）绘制由 x = funx(t) 和 y = funy(t) 定义的曲线。
fplot(funx,funy,tinterval) 将在指定区间绘图。将区间指定为 [tmin tmax] 形式的二元素向量。
fplot(___,LineSpec) 指定线型、标记符号和线条颜色。例如，'-r' 绘制一根红色线条。在上述语法中的任何输入参量组合后使用此选项。
fplot(___,Name,Value) 使用一个或多个名称-值对组参量指定线条属性。例如，'LineWidth',2 指定 2 磅的线宽。
fplot(ax,___) 将图形绘制到 ax 指定的坐标区中，而不是当前坐标区 (gca) 中。指定坐标区作为第一个输入参量。
fp = fplot(___) 返回 FunctionLine 对象或 ParameterizedFunctionLine 对象，具体情况取决于输入。使用 fp 查询和修改特定线条的属性。
%}
fplot(@(x)sin(1./x),[0,0.2]);
fplot(@(t)t.*sin(t),@(t)t.*cos(t),[0,10*pi],'-r');

% 其他坐标系的二维曲线
%{
对数坐标图 semilogx 函数
semilogx(X,Y) 在 x 轴上使用以 10 为底的对数刻度、在 y 轴上使用线性刻度来绘制 x 和 y 坐标。
要绘制由线段连接的一组坐标，请将 X 和 Y 指定为相同长度的向量。
要在同一组坐标区上绘制多组坐标，请将 X 或 Y 中的至少一个指定为矩阵。
semilogx(X,Y,LineSpec) 使用指定的线型、标记和颜色创建绘图。
semilogx(X1,Y1,...,Xn,Yn) 在同一组坐标轴上绘制多对 x 和 y 坐标。此语法可替代将坐标指定为矩阵的形式。
semilogx(Y) 绘制 Y 对一组隐式 x 坐标的图。
    如果 Y 是向量，则 x 坐标范围从 1 到 length(Y)。
    如果 Y 是矩阵，则对于 Y 中的每个列，图中包含一个对应的行。x 坐标的范围是从 1 到 Y 的行数。
    如果 Y 包含复数，semilogx 绘制 Y 的虚部对 Y 的实部的图。但是，如果同时指定了 X 和 Y，MATLAB 会忽略虚部。
semilogx(Y,LineSpec) 使用隐式 x 坐标绘制 Y，并指定线型、标记和颜色。
%}
% logspace(a,b) 生成一个由在 10^a 和 10^b 之间的 50 个对数间距点组成的行向量
x = logspace(-1,2);
y = x;
semilogx(x,y);

%{
极坐标图 polarplot 函数
polarplot(theta,rho) 在极坐标中绘制线条，由 theta 表示弧度角，rho 表示每个点的半径值。
    输入必须为长度相等的向量或大小相等的矩阵。
    如果输入为矩阵，polarplot 将绘制 rho 的列对 theta 的列的图。
    也可以一个输入为向量，另一个为矩阵，但向量的长度必须与矩阵的一个维度相等。
polarplot(theta,rho,LineSpec) 设置线条的线型、标记符号和颜色。
polarplot(theta1,rho1,...,thetaN,rhoN) 绘制多个 rho,theta 对组。
polarplot(theta1,rho1,LineSpec1,...,thetaN,rhoN,LineSpecN) 指定每个线条的线型、标记符号和颜色。
polarplot(rho) 按等间距角度（介于 0 和 2π 之间）绘制 rho 中的半径值。
polarplot(rho,LineSpec) 设置线条的线型、标记符号和颜色。
%}
theta = 0:0.01:2*pi;
rho = sin(theta).*cos(theta);
polarplot(theta,rho);

% 统计图
%{
条形图 bar 函数
bar(y) 创建一个条形图，y 中的每个元素对应一个条形。
    要绘制单个条形序列，请将 y 指定为长度为 m 的向量。这些条形沿 x 轴从 1 到 m 依次放置。
    要绘制多个条形序列，请将 y 指定为矩阵，每个序列对应一列。
bar(x,y) 在 x 指定的位置绘制条形。
bar(___,width) 设置条形的相对宽度以控制组中各个条形的间隔。将 width 指定为标量值。
bar(___,style) 指定条形组的样式。例如，使用 'stacked' 将每个组显示为一个多种颜色的条形。
bar(___,color) 设置所有条形的颜色。例如，使用 'r' 表示红色条形。
bar(___,Name,Value) 使用一个或多个名称-值对组参量指定条形图的属性。仅使用默认 'grouped' 或 'stacked' 样式的条形图支持设置条形属性。
%}
x = [2021 2022 2023];
y = [10 20;20 30;100 200];
bar(x,y);

%{
直方图 histogram 函数（分布直方图，即每个区间 “数据的数量” 的图）
histogram(X) 基于 X 创建直方图。histogram 函数使用自动分 bin 算法，然后返回均匀宽度的 bin，这些 bin 可涵盖 X 中的元素范围并显示分布的基本形状。
    histogram 将 bin 显示为矩形条，这样每个矩形的高度就表示 bin 中的元素数量。
histogram(X,nbins) 指定 bin 的数量。
histogram(X,edges) 将 X 划分为在向量 edges 中指定 bin 边界的 bin。
histogram('BinEdges',edges,'BinCounts',counts) 绘制指定的 bin 计数，而不执行任何数据分 bin。
histogram(C) 通过为分类数组 C 中的每个类别绘制一个条形来绘制直方图。
histogram(C,Categories) 只绘制 C 中类别的子集。
histogram('Categories',Categories,'BinCounts',counts) 手动指定类别和关联的 bin 计数。histogram 绘制指定的 bin 计数，而不执行任何数据分 bin。
histogram(___,Name,Value) 使用一个或多个名称-值参量为上述任一语法指定其他参数。例如，指定 Normalization 以使用不同类型的归一化。
histogram(ax,___) 在指定的坐标区中而不是当前坐标区 (gca) 中绘图。ax 可以位于上述语法中的任何输入参量组合之前。
h = histogram(___) 返回 Histogram 对象。使用此语法可检查并调整直方图的属性。
%}
x = randn(1000);
nbins = 25;
h = histogram(x,nbins);
counts = h.Values;

%{
面积类图形 pie 函数（饼状图）
pie(X) 使用 X 中的数据绘制饼图。饼图的每个扇区代表 X 中的一个元素。
    如果 sum(X) ≤ 1，X 中的值直接指定饼图扇区的面积。
    如果 sum(X) < 1，pie 仅绘制部分饼图。
    如果 sum(X) > 1，则 pie 通过 X/sum(X) 对值进行归一化，以确定饼图的每个扇区的面积。
    如果 X 为 categorical 数据类型，则扇区对应于类别。每个扇区的面积是类别中的元素数除以 X 中的元素数的结果。
pie(X,explode) 将扇区从饼图偏移一定位置。
    explode 是一个由与 X 对应的零值和非零值组成的向量或矩阵。
    pie 函数仅将对应于 explode 中的非零元素的扇区偏移一定的位置。
    如果 X 为 categorical 数据类型，则 explode 可以是由对应于类别的零值和非零值组成的向量，或者是由要偏移的类别名称组成的元胞数组。
pie(X,labels) 指定用于标注饼图扇区的选项。在本例中，X 必须为数值。
pie(X,explode,labels) 偏移扇区并指定文本标签。X 可以是数值或分类数据类型。
pie(ax,___) 将图形绘制到 ax 指定的坐标区中，而不是当前坐标区 (gca) 中。选项 ax 可以位于上述语法中的任何输入参量组合之前。
p = pie(___) 返回一个由补片和文本图形对象组成的向量。
%}
x = [1:2:9];
pie(x);

%{
散点类图形 scatter 函数
scatter(x,y) 在向量 x 和 y 指定的位置创建一个包含 “圆形标记” 的散点图。
    要绘制一组坐标，请将 x 和 y 指定为等长向量。
    要在同一组坐标区上绘制多组坐标，请将 x 或 y 中的至少一个指定为矩阵。
scatter(x,y,sz) 指定圆圈大小。
    要对所有圆使用相同的大小，请将 sz 指定为标量。
    要绘制不同大小的每个圆，请将 sz 指定为向量或矩阵。
scatter(x,y,sz,c) 指定圆颜色。可以为所有圆指定一种颜色，也可以更改颜色。例如，您可以通过将 c 指定为 "red" 来绘制所有红色圆。
scatter(___,"filled") 填充圆。可将 "filled" 选项与上述语法中的任何输入参量组合一起使用。
scatter(___,mkr) 指定标记类型（此时不能再 'filled'）。"o" (默认) | "+" | "*" | "." | "x" | ...
%}
t = linspace(0,2*pi,51);
x = 16*sin(t).^3;
y = 13*cos(t) - 5*cos(2*t) - 2*cos(3*t) - cos(4*t);
scatter(x,y,'red','filled');

% 矢量类图形
%{
quiver 函数
quiver(X,Y,U,V) 在由 X 和 Y 指定的笛卡尔坐标上绘制具有定向分量 U 和 V 的箭头。
    就是 (X,Y)->(X+U,Y+V) 的箭头。
    例如，第一个箭头源于点 X(1) 和 Y(1)，按 U(1) 水平延伸，按 V(1) 垂直延伸。
    默认情况下，quiver 函数缩放箭头长度，使其不重叠。（箭头可能指不到 “终点”，但是方向不变）
quiver(U,V) 在等距点上绘制箭头，箭头的定向分量由 U 和 V 指定。
    如果 U 和 V 是向量，则箭头的 x 坐标范围是从 1 到 U 和 V 中的元素数，并且 y 坐标均为 1。
    如果 U 和 V 是矩阵，则箭头的 x 坐标范围是从 1 到 U 和 V 中的列数，箭头的 y 坐标范围是从 1 到 U 和 V 中的行数。
quiver(___,scale) 调整箭头的长度：
    当 scale 为正数时，quiver 函数会自动调整箭头的长度，使其不重叠，然后将箭头长度拉伸 scale 倍。例如，scale 为 2 会使箭头长度加倍，scale 为 0.5 会使箭头长度减半。
    当 scale 为 'off' 或 0 时，如 quiver(X,Y,U,V,'off')，则禁用自动缩放。
quiver(___,LineSpec) 设置线型、标记和颜色。
    标记出现在由 X 和 Y 指定的点上。如果使用 LineSpec 指定标记，则 quiver 不显示箭尖。
    要指定标记并显示箭尖，请改为设置 Marker 属性。
quiver(___,LineSpec,'filled') 填充由 LineSpec 指定的标记。
quiver(___,Name,Value) 使用一个或多个名称-值对组参量指定箭头图属性。在所有其他输入参量之后指定名称-值对组参量。名称-值对组参量应用于箭头图中的所有箭头。
quiver(ax,___) 在 ax 指定的坐标区中而不是当前坐标区 (gca) 中创建箭头图。参量 ax 可以置于上述语法中的任何输入参量组合之前。
q = quiver(___) 返回 Quiver 对象。此对象对于在创建箭头图后控制其属性非常有用。
%}
A = [4,5];
quiver(0,0,A(1),A(2));

%% 图形属性设置
% 线型、标记、颜色
%{
（LineSpec）
指定为包含符号的字符串标量。符号可以按任意顺序显示
    例如："--or" 是带有圆形标记的红色虚线
不需要同时指定所有三个特征
    例如，如果忽略线型，只指定标记，则绘图只显示标记，“不显示” 线条。
%}

% 图形标注（可用 {} 包含 Latex 输入）
%{
title：图形标题
xlabel：x轴说明
ylabel：y轴说明
text：text(x,y,txt) 向当前坐标区中的一个或多个数据点添加文本描述，
    默认坐标 (x,y) 对应的是文本的左下角
legend：图例1，图例2，...，顺序与绘图时的顺序相同
%}

% 坐标控制
%{
axis 函数
axis(limits) 指定当前坐标区的范围。以包含 4 个、6 个或 8 个元素的向量形式指定范围。
    axis([xmin,xmax,ymin,ymax]) 指定当前坐标区的范围
    axis([xmin,xmax,ymin,ymax,zmin,zmax]) 还指定 z轴 的范围
    [xmin xmax ymin ymax zmin zmax cmin cmax] 还设置颜色范围。cmin 是对应于颜色图中的第一种颜色的数据值。cmax 是对应于颜色图中的最后一种颜色的数据值。
    [thetamin thetamax rmin rmax] 将 theta 坐标轴范围设置为从 thetamin 到 thetamax。将 r 坐标轴范围设置为从 rmin 到 rmax。
axis style 使用预定义样式设置轴范围和尺度。
    axis equal 以便沿着每个坐标轴使用相等的数据单位长度。
    axis square 产生正方形坐标系（默认为矩形）
axis mode 设置 MATLAB 是否自动选择范围。
    将模式指定为 manual、auto 或半自动选项之一，例如 'auto x'，自动选择 x 坐标轴范围。。
axis ydirection，指定 y 轴方向，其中 ydirection 为：
    xy 默认方向。y 轴值从下到上逐渐增加。
    ij 反转方向。y 轴值从上到下逐渐增加。
axis visibility，指定坐标区线条和背景的可见性，其中 visibility 为：
    "on" 显示坐标区线条和背景（默认）
    "off" 关闭坐标区背景的显示
    值 1 或 true 显示坐标区线条和背景（自 R2024a 起）
    0 或 false 关闭坐标区背景的显示（自 R2024a 起）
    值 matlab.lang.OnOffSwitchState.on 显示坐标区线条和背景（自 R2024a 起）
    值 matlab.lang.OnOffSwitchState.off 关闭坐标区背景的显示（自 R2024a 起）
lim = axis 返回当前坐标区的 x 轴和 y 坐标轴范围。对于三维坐标区，还会返回 z 坐标轴范围。对于极坐标区，它返回 theta 轴和 r 坐标轴范围。
___ = axis(ax,___) 使用 ax 指定的坐标区或极坐标区，而不是使用当前坐标区。指定 ax 作为上述任何语法的第一个输入参量。
    将字符向量类型的输入参量用单引号引起来，例如 axis(ax,'equal')。
%}

%{
grid 函数：给坐标系加网格和边框（默认是无网格线）
grid on 显示 gca 命令返回的当前坐标区的主网格线。主网格线从每个刻度线延伸。
grid off 删除当前坐标区或图上的所有网格线。
grid 切换改变主网格线的可见性。
grid minor 切换改变次网格线的可见性。
    次网格线出现在刻度线之间。并非所有类型的图都支持次网格线。
grid(visibility) 通过指定 visibility 值来显示或隐藏网格。可以将 visibility 指定为 "on"、"off"、逻辑值或 OnOffSwitchState 值。
grid(target,___) 使用 target 指定的坐标区或独立可视化，而不是使用当前坐标区。在所有其他参量之前指定 target。
%}
x = linspace(0,2*pi,200);
y = [sin(x);sin(2*x);sin(x/2)];
plot(x,y);
axis([0,8,-1.5,1.5]);
title('三个正弦函数曲线y=sin{\theta}','副标题','FontSize',24);
xlabel('X');
ylabel('Y');
text(2.5,sin(2.5),'sin(x)');
text(2.5,sin(2*2.5),'sin(2x)');
legend('sin(x)','sin(2x)','sin(0.5x)');

% 图形保持
%{
hold 函数
hold on 将坐标区的保留状态设置“打开”，这将保留当前坐标区中的绘图，从而使新添加到坐标区中的绘图不会删除现有绘图。
    当保留状态处于打开状态时，新绘图基于坐标区的 ColorOrder 和 LineStyleOrder 属性使用后续的颜色和线型。
    MATLAB 将调整坐标区的范围、刻度线和刻度标签以显示完整范围的数据。如果坐标区对象不存在，则 hold 命令会创建一个。
hold off 将坐标区保留状态设置为 off，从而使新添加到坐标区中的绘图清除现有绘图并重置所有的坐标区属性。
    当保留状态处于关闭状态时，添加到坐标区的下一个绘图基于坐标区的 ColorOrder 和 LineStyleOrder 属性使用第一个颜色和线型。此选项为默认行为。
hold 在 on 和 off 之间切换保留状态。
hold(state) 通过指定 state 值来设置坐标区保留状态。
    可以将 state 指定为 "on"、"off"、逻辑值或 OnOffSwitchState 值。
hold(ax,___) 为 ax 指定的坐标区而非当前坐标区设置保留状态。在所有其他参量之前指定 ax。
%}
fplot(@(t)cos(t),@(t)sin(t),'b');
axis equal;
hold on;
fplot(@(t)2*cos(t),@(t)2*sin(t),'r');

%% 三维图形绘制
% 三维曲线
%{
plot3 函数、fplot3 函数
和 plot、fplot 函数相似，只能画 “曲线”
必须要 x(t)、y(t)、z(t)，而不能只有一个函数，因为那样就是 “曲面” 了
%}
t = linspace(0,10*pi,300);
x = sin(t)+t.*cos(t);
y = cos(t)-t.*sin(t);
z = t;
plot3(x,[y;y+20],[z',z']);
X = @(t) sin(t)+t.*cos(t);
Y = @(t) cos(t)-t.*sin(t);
fplot3(X,Y,@(t)t,[0,10*pi]);

% 三维曲面
% 平面网格数据的生成：
%   （1）利用矩阵运算生成
%   （2）利用 meshgrid 函数生成：[X,Y] = meshgrid(x,y)
x = [2:6];
y = [3:8]';
X = ones(size(y))*x; % size(y) 返回 “6行1列”
Y = y*ones(size(x));
[X,Y] = meshgrid(x,y);


% 绘制三维曲面的函数
%{
mesh 函数和 surf 函数
mesh(X,Y,Z) 创建一个网格图，该网格图为三维曲面，有实色边颜色，无面颜色。
    该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度。边颜色因 Z 指定的高度而异。
mesh(Z) 创建一个网格图，并将 Z 中元素的列索引和行索引用作 x 坐标和 y 坐标。
mesh(___,C) 进一步指定边的颜色。
mesh(ax,___) 将图形绘制到 ax 指定的坐标区中，而不是当前坐标区中。指定坐标区作为第一个输入参量。
mesh(___,Name,Value) 使用一个或多个名称-值对组参量指定曲面属性。例如，'FaceAlpha',0.5 创建半透明网格图。
s = mesh(___) 将返回一个图曲面对象。在创建网格图后，使用 s 修改网格图。

surf(X,Y,Z) 创建一个三维曲面图，它是一个具有实色边和实色面的三维曲面。
    该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度。曲面的颜色根据 Z 指定的高度而变化。
此外，surf(X,Y,Z,C) 还指定曲面的颜色。
surf 函数的其他用法与 mesh 函数相似

[m,n] = size(Z)
X 指定为大小与 Z 相同的 “矩阵” 或长度为 n 的 “向量”
Y 指定为大小与 Z 相同的 “矩阵” 或长度为 m 的 “向量”
%}
x = -1:0.2:2;
[X,Y] = meshgrid(x);
Z = X.*exp(-X.^2-Y.^2);
plot3(X,Y,Z);
mesh(X,Y,Z);
surf(X,Y,Z);

%{
fmesh 函数和 fsurf 函数
fmesh(f) 在 x 和 y 的默认区间 [-5 5] 为表达式 z = f(x,y) 创建网格图。
fmesh(f,xyinterval) 将在指定区间绘图。
    要对 x 和 y 使用相同的区间，将 xyinterval 指定为 [min max] 形式的二元素向量。
    要使用不同的区间，指定 [xmin xmax ymin ymax] 形式的四元素向量。
fmesh(funx,funy,funz) 在默认区间 [-5 5]（对于 u 和 v）绘制由 x = funx(u,v)、y = funy(u,v)、z = funz(u,v) 定义的参数化网格。
fmesh(funx,funy,funz,uvinterval) 在指定区间绘制参数化网格。
    要对 u 和 v 使用相同的区间，将 uvinterval 指定为 [min max] 形式的二元素向量。
    要使用不同的区间，指定 [umin umax vmin vmax] 形式的四元素向量。
fmesh(___,LineSpec) 设置网格的线型、标记符号和颜色。例如，'-r' 指定红色线条。在前面的任何输入参量组合之后使用此选项。
fmesh(___,Name,Value) 使用一个或多个名称-值对组参量指定网格的属性。可将此选项与上述语法中的任何输入参量组合一起使用。
fmesh(ax,___) 将图形绘制到 ax 指定的坐标区中，而不是当前坐标区 gca 中。
fs = fmesh(___) 返回 FunctionSurface 对象或 ParameterizedFunctionSurface 对象，具体情况取决于输入。使用 fs 来查询和修改特定曲面的属性。

fsurf 函数与 fmesh 函数的用法相似
%}
fmesh(@(x,y) sin(x)+cos(y));
alpha(0.8); % 设置透明度
fsurf(@(x,y) sin(x)+cos(y));

%% 句柄
% 图形对象句柄及属性
%{
对象句柄值的获取
句柄引用图形对象的具体事例。使用对象句柄设置和查询对象属性的值。
对象的句柄值，类似于编程时的引用，将对象的句柄值赋值给变量后，该变量就可以代表指定的绘图对象。
当创建图形对象时，可以将对象的句柄保存到变量中
%}
x = 1:10;
y = x.^2;
h = plot(x,y); % 句柄
h1 = text(5,25,"说明");
h1.FontSize = 24;
%{
句柄变量是对象。
不要尝试对句柄执行将句柄转换为数值、字符或其他类型的操作。
例如，不能执行以下操作：
    对句柄执行算术运算
    在逻辑语句中直接使用句柄，而不转换为逻辑值
    在逻辑语句中根据图窗句柄的数值（整数）做判断
    将句柄与数字数组中的数据合并
    将句柄转换为字符向量，或在字符向量运算中使用句柄
%}

%{
对象属性的获取、设置
get 函数，可以获取某个对象的属性
set 函数，可以设置某个对象的属性
%}
x = linspace(0,2*pi,100);
y = sin(x);
h = plot(x,y);
get(h);
set(h,'Color','red');

%% 窗口控制
% 图形窗口的分割
% 子图：同一图形窗口中的不同坐标系下的图形为子图
%{
subplot 函数
subplot(m,n,p) 将当前图窗划分为 m×n 网格，并在 p 指定的位置创建坐标区。
    MATLAB 按行优先对子图位置进行编号。第一个子图是第一行的第一列，第二个子图是第一行的第二列，依此类推。
    如果指定的位置已存在坐标区，则此命令会将该坐标区设为当前坐标区。
    p 可为数组，将多个子图合并作图
subplot(m,n,p,'replace') 删除位置 p 处的现有坐标区并创建新坐标区。
subplot(m,n,p,'align') 创建新坐标区，以便对齐图框。此选项为默认行为。
subplot(m,n,p,ax) 将现有坐标区 ax 转换为同一图窗中的子图。
subplot('Position',pos) 在 pos 指定的自定义位置创建坐标区。使用此选项可定位未与网格位置对齐的子图。
    指定 pos 作为 [left bottom width height] 形式的四元素向量。如果新坐标区与现有坐标区重叠，新坐标区将替换现有坐标区。
subplot(___,Name,Value) 使用一个或多个名称-值对组参量修改坐标区属性。在所有其他输入参量之后设置坐标区属性。
ax = subplot(___) 创建一个 Axes 对象、PolarAxes 对象或 GeographicAxes 对象。以后可以使用 ax 修改坐标区。
subplot(ax) 将 ax 指定的坐标区设为父图窗的当前坐标区。如果父图窗尚不是当前图窗，此选项不会使父图窗成为当前图窗。
%}
x = linspace(0,2*pi,100);
subplot(2,2,1);
plot(x,sin(x));
title('sin(x)');

subplot(2,2,2);
plot(x,cos(x));
title('cos(x)');

subplot(2,2,3);
plot(x,tan(x));
title('tan(x)');

subplot(2,2,4);
plot(x,cot(x));
title('cot(x)');

%{
tiledlayout 函数
tiledlayout 创建分块图布局，用于显示当前图窗中的多个绘图（也称为子图）。
    布局可以显示任意数量的绘图并根据图窗的大小和坐标区的数量调整布局。
    如果没有图窗，MATLAB 会创建一个图窗并将布局放入其中。
    如果当前图窗包含一个现有布局或坐标区，MATLAB 会将其替换为新布局。 (自 R2024b 起)
分块图布局包含覆盖整个图窗或父容器的不可见图块网格。每个图块可以包含一个用于显示绘图的坐标区对象。
    创建布局后，调用 nexttile 函数以将坐标区对象放置到布局中。然后调用绘图函数在该坐标区中绘图。
tiledlayout(m,n) 创建一个固定大小的网格，最多可显示 m*n 个绘图。该网格有 m 行和 n 列。
tiledlayout(arrangement) 创建一个可以容纳任意数量的坐标区的布局。
    最初，只有一个空图块填充整个布局。
    指定一个排列值来控制后续坐标区的布局：
        "flow" - 为坐标区网格创建布局，该布局可以根据图窗的大小和坐标区的数量调整。
        "vertical" - 为坐标区的垂直堆叠创建布局。 (自 R2023a 起)
        "horizontal" - 为坐标区的水平堆叠创建布局。 (自 R2023a 起)
        可以不带括号指定 arrangement 参量。例如，tiledlayout vertical 为坐标区的垂直堆叠创建布局。
tiledlayout(___,Name,Value) 使用一个或多个名称-值对组参量指定布局的其他选项。请在所有其他输入参量之后指定这些选项。
    例如，tiledlayout(2,2,"TileSpacing","compact") 创建一个 2×2 布局，图块之间采用最小间距。
tiledlayout(parent,___) 在指定的父容器中而不是在当前图窗中创建布局。请在所有其他输入参量之前指定父容器。
t = tiledlayout(___) 返回 TiledChartLayout 对象。创建布局后，使用 t 配置布局的属性。

nexttile 创建一个坐标区对象，再将其放入当前图窗中的分块图布局的下一个空图块中。
    如果当前图窗中没有布局，则 nexttile 会创建一个新布局并使用 'flow' 图块排列进行配置。
    生成的坐标区对象是当前坐标区，因此下一个绘图命令可以在其中进行绘制。
nexttile(span) 创建一个占据布局中心网格多行或多列的坐标区对象。
    指定 span 作为 [r c] 形式的向量。坐标区占据 r 行×c 列的图块。坐标区的左上角位于网格中第一个空的 r×c 区域的左上角。
nexttile(tilelocation) 将当前坐标区指定为 tilelocation 指定的图块中的坐标区或独立可视化。
    通常，当您要修改现有坐标区或独立可视化时，此语法非常有用。然而，在某些情况下，nexttile 会创建一个新坐标区对象：
        当指定的图块为空时，nexttile 会在该图块中创建坐标区对象。
        如果指定的图块包含坐标区或独立可视化对象的一部分但不包含其左上角，nexttile 将替换现有对象。
            例如，如果 tilelocation 引用占据多个图块的坐标区对象 “中间” 的图块，nexttile 会在您指定的图块中用新坐标区对象替换现有坐标区对象。
nexttile(tilelocation,span) 创建一个占据多行或多列的坐标区对象，从 tilelocation 指定的图块开始。
    如果指定的图块中有坐标区或独立可视化，nexttile 会将该对象设为当前坐标区或替换它：
        如果现有坐标区或独立可视化对象占据与 tilelocation 和 span 参量指定的相同的图块集，则 nexttile 会将该对象设为当前坐标区。
        如果现有坐标区或独立可视化对象占据的图块集不同于 tilelocation 和 span 参量指定的图块集，则 nexttile 会使用新的 tilelocation 和 span 值用新的坐标区对象替换现有对象。
若 nexttile 指定的图块超出预设界限，界限会自动扩展。
nexttile(t,___) 对 t 指定的分块图布局进行操作。请在所有其他输入参量之前指定 t。如果使用多个布局，或布局位于面板或选项卡（而不是图窗）中，则此语法非常有用。
ax = nexttile(___) 返回坐标区对象。使用 ax 对坐标区设置属性。也可以将 ax 作为输入参量传递给对坐标区对象执行操作的其他图形函数。例如，可以调用 colormap 或 colororder 函数来更改坐标区的颜色方案。
%}
tiledlayout(2,2);
[X,Y,Z] = peaks(20);
nexttile
surf(X,Y,Z)

nexttile
contour(X,Y,Z)

nexttile
imagesc(Z)

nexttile
plot3(X,Y,Z)

%% 元胞数组
% 类似于 C++ 的 “结构体” 的实例，但是没有 “字段”，而且不一定是线性的，可以是 “多维数组”
% 元胞数组（Cell Array）是一种特殊的数据类型，用于存储不同类型、不同大小的数据（如数字、字符串、矩阵、结构体甚至其他元胞数组）。
% 它的每个元素称为一个元胞（Cell），元胞之间彼此独立，类似于“容器”或“抽屉”，可以灵活组织异构数据。

% 创建元胞数组
% 直接赋值
% 使用大括号 {} 定义元胞
C = {'文本', 123, [1 2; 3 4], magic(3)}; % 包含字符串、数字、矩阵

% 函数生成
% cell(m,n)，创建 m×n 的空元胞数组。
% cell(sz)，返回由空矩阵构成的元胞数组
C = cell(2, 3);

% num2cell / mat2cell，将矩阵转换为元胞数组。
% （本质是 “划分” 矩阵，得到的每个元胞都是 “矩阵”）
%{
num2cell 函数
C = num2cell(A) 通过将 A 的每个元素放置于 C 的一个单独元胞中，来将数组 A 转换为元胞数组 C。
C = num2cell(A,dim) 将 A 的内容划分成 C 中单独的元胞，其中 dim 指定每个元胞包含 A 的哪个维度。
    dim 也可为数组

mat2cell 函数
C = mat2cell(A,dim1Dist,...,dimNDist) 将数组 A 划分为更小的数组，并在元胞数组 C 中返回它们。
    向量 dim1Dist,...dimNDist 指定如何划分 A 的行、列和（如果适用）更高维度。C 中较小的数组可以具有不同大小。A 可以包含任何数据类型。
    例如：
        dim1Dist = [2,3] 表示将 A 的 行数 划分成 2+3 行，分到 两个 元胞中
        dim2Dist = [1,2,3] 表示将 A 的 列数 划分为 1+2+3 列，分到 三个 元胞中
        dimNDist 表示第 N 维度的划分方式
        最后得到的元胞数组，就是以 dim1Dist,...,dimNDist 表示的 “网格” 划分 A 得到的。
C = mat2cell(A,rowDist) 将数组 A 划分为一个 n×1 元胞数组 C，其中 n 等于 rowDist 中元素的数量。
%}
A = [1 2; 3 4];
C = num2cell(A); % 每个元素转为独立元胞
C = num2cell(A,1); % 每个元胞是 A 的一列
C = num2cell(A,[2 3]); % 每个元胞是 A 的一个 “水平面”
A = reshape(1:20,5,4)';
C = mat2cell(A,[2 2],[3 2]); % 将 A 划分为两个 2×3 和 2 个 2×2 子数组。

% 元胞数组的访问
%{
获取元胞内容：C{row,col}	返回第 row 行第 col 列的 “数据”
获取元胞本身（不提取）：C(row,col) 返回第 row 行第 col 列的 “元胞”
    注意：返回的是仅包含该元胞的 “子元胞数组”（仍是 cell 类型）
多级索引	：C{idx1}{idx2}	（若元胞内仍是元胞，即元胞仍是元胞数组）
%}
C = {'MATLAB', [10 20], {1, 2}};
str = C{1};      % 获取第一个元胞的内容: 'MATLAB'
subCell = C{3};  % 获取第三个元胞的内容: {1, 2}
nested = C{3}{1};% 嵌套访问: 1

% 元胞数组的修改和删除
% 修改元胞内容
%{
使用{}赋值：
    直接对内容赋值
    C{i} = value;
使用()赋值：
    对子元胞数组赋值，由于 C(i) 返回的是仅包含一个元胞的子元胞数组，所以赋的值也得是 “元胞数组”，且大小为 1
    C(i) = {value};
%}
C{2} = '新内容'; % 将第二个元胞的内容替换为字符串
C(3) = {{3,3,3}};

% 线性索引
% 按遍历顺序索引
C{5} = 0;

% 扩展元胞数组
C{3,4} = rand(3); % 扩展为3行4列，未指定位置填充空元胞[]（内容为空的元胞）

% 删除元胞
C(1,:) = []; % 删除第一行所有元胞

% 元胞数组的常用操作
% 遍历元胞
for i = 1:numel(C) % numel(A) 返回数组 A 中的元素数目，等同于 prod(size(A))
    disp(C{i});    % 逐个显示元胞内容
end

% 判断元胞类型（元胞内容的类型）
ischar(C{1}); % 检查第一个元胞是否为字符

%转换操作
% 将数值型元胞合并为矩阵
%{
cell2mat 函数（需元胞内容同类型）。
A = cell2mat(C) 将元胞数组转换为普通数组。
    元胞数组的元素必须全都包括相同的数据类型，并且生成的数组也是该数据类型。
C 的内容必须支持串联到 N 维矩形中。否则，结果将不确定。
    例如，同一列中的元胞的内容必须具有相同的列数，但不需要具有相同的行数。
%}
C = {1,    [2 3 4];
     [5; 9], [6 7 8; 10 11 12]};
A = cell2mat(C);

% 对每个元胞应用函数
%{
cellfun 函数
A = cellfun(func,C) 将函数 func 应用于元胞数组 C 的每个元胞的内容，每次应用于一个元胞。
    然后 cellfun 将 func 的输出串联成输出数组 A，因此，对于 C 的第 i 个元素来说，A(i) = func(C{i})。
    输入参量 func 是一个函数的函数句柄，此函数接受一个输入参量并返回一个标量。
        func 的输出必须始终属于相同的数据类型才能使用此语法。
        如果函数输出具有不同数据类型，则必须将 UniformOutput 名称-值参量设置为 false。
    数组 A 和元胞数组 C 具有相同的大小。
    不能指定 cellfun 计算 A 的各元素的顺序，也不能期望它们按任何特定的顺序完成计算。
A = cellfun(func,C1,...,Cn) 将 func 应用于 C1,...,Cn 的各元胞的内容，因此 A(i) = func(C1{i},...,Cn{i})。
    函数 func 必须接受 n 个输入参量并返回一个标量。
    元胞数组 C1,...,Cn 的大小必须全部相同。
A = cellfun(___,Name,Value) 应用 func 并使用一个或多个 Name,Value 对组参量指定其他选项。
    例如，要以 元胞数组 形式返回输出值，请指定 'UniformOutput' 为 false。
    当 func 返回的值不能串联成数组时，可以按元胞数组的形式返回 A。
    可以将 Name,Value 对组参量与上述任何语法中的输入参量结合使用。
当 func 返回 m 个输出值时，[A1,...,Am] = cellfun(___) 返回多个输出数组 A1,...,Am。
    func 可以返回不同数据类型的输出参量，但每次调用 func 时返回的每个输出的数据类型必须相同。可将此语法与上述语法中的任何输入参量一起使用。
%}
sizes = cellfun(@size, C, 'UniformOutput', false); % 获取每个元胞的尺寸，返回一个元胞数组

%% 结构体
% 类似于 Python 的 “字典”，也类似于 C++ 的 “结构体” 的实例
% 结构体数组可以看做元素都是同种结构体的普通数组。
% 结构体（Structure）是一种复合数据类型，用于将不同类型、不同含义的数据组织在一个变量中。
% 每个结构体由多个 “字段（Field）” 组成，每个字段可以存储任意类型的数据（如数值、字符串、数组、元胞数组甚至其他结构体）。
% 结构体特别适合管理具有逻辑关联的异构数据。

% 创建结构体
% 直接赋值
student.name = '张三';
student.age = 21;
student.grades = [90, 85, 78];
student.contact.email = 'zhangsan@example.com'; % 嵌套结构体

% 使用 struct 函数
%{
s = struct(field1,value1,...,fieldN,valueN) 创建一个包含多个字段的 “结构体数组”。
如果 value 的所有输入都不是元胞数组，或者 value 中作为元胞数组的所有输入都是标量（仅有一个元素），则 s 是 “标量结构体”。
如果任一 value 输入是非标量元胞数组，则 s 具有与该元胞数组相同的维度。
    此外，如果两个或多个 value 输入是非标量元胞数组，则它们必须都具有 “相同的维度”。
    若想让字段的值为元胞数组，需要嵌套在外层元胞数组内，即{{...}}
对于类型为标量元胞数组或任何其他数据类型的数组的任何 value，struct 将 value 的内容插入 s 的所有元素的相关字段中。
    例如，s = struct('x',{'a','b'},'y','c') 返回 s(1).x = 'a'、s(2).x = 'b'、s(1).y = 'c' 和 s(2).y = 'c'。
如果任何 value 输入是空元胞数组 {}，则输出 s 是空 (0×0) 结构体。（一个元胞数组为空，所有元胞数组都得为空）
要指定一个空字段并保留其他字段的值，请改用 [] 作为 value 输入。
%}
struct([]);
teacher = struct('name', '李四', 'subject', '数学', 'years', 10);
new_teacher = struct(teacher);
books = struct('name',{{'Machine learning','Data Mining'}});

% 结构体数组
% 创建 1×2 的结构体数组
patients(1).name = 'Alice';
patients(1).testResults = [72, 80];
patients(2).name = 'Bob';
patients(2).testResults = [68, 91];

% 访问结构体数据
%{
访问字段：struct.field
动态添加字段：struct.newfield = value
删除字段：struct = rmfield(struct, fields)，删除指定字段
    rmfield 函数，返回删除指定字段后的结构体数组，fields 可为数组
嵌套字段访问：struct.field.field1，访问嵌套结构体的字段
遍历结构体数组：同遍历数组
%}
teacher.name;
teacher.abc = 1;
teacher = rmfield(teacher,{'years','abc'});
for p = patients
    disp(p.name);
end	

% 结构体的常用函数
%{
fieldnames：获取所有字段名
fields = fieldnames(S) 返回元胞数组，包含结构体数组 S 的字段名称。
要返回字段的值，使用 struct2cell 函数。struct2cell 和 fieldnames 以相同的顺序返回值和字段名称。

isfield：检查字段是否存在
TF = isfield(S,field)
如果 field 是包含多个名称的数组且 S 是结构体数组，则 TF 是 “大小相同” 的 “逻辑数组”。
如果 S 不是结构体数组，则 isfield 返回 0。

orderfields：按字母顺序排列字段
S = orderfields(S1) 按名称对 S1 中的字段排序。
    由于字段名称只能包含字母、数字和下划线，此语法按 ASCII 顺序对字段名称进行排序。所有 “大写字母” 排在所有 “小写字母” “之前”。
S = orderfields(S1,S2) 返回 S1 的副本，其字段已重新排序以匹配 S2 的字段顺序。
    输入结构体数组 S1 和 S2 必须具有相同的字段名称。
S = orderfields(S1,C) 按输入数组 C 匹配名称顺序。
    S1 中每个字段的名称必须在 C 中出现一次。C 可为元胞数组（若名称为 “字符串数组”，C 必须为元胞数组）
S = orderfields(S1,P) 按置换向量 P 匹配顺序。
    如果 S1 有 n 个字段，则 P 的元素是从 1 到 n 的整数，按任意顺序排列。
        例如，如果 S1 有三个字段，P 是 [3 1 2]，则 S1 的第三个字段是输出 S 的第一个字段。当需要以相同的方式对多个结构体数组进行排序时，此语法非常有用。
[S,Pout] = orderfields(___) 还返回一个置换向量。
    Pout 的元素是从 1 到 n 的整数，其排列顺序反映了字段顺序的变化。您可将此语法与上述语法中的任何输入参量一起使用。

struct2table：将结构体数组转换为表格
T = struct2table(S) 将结构体数组转换为表。输入结构体的每个字段都成为输出表中的一个变量。
    如果输入是具有 n 个字段的 “标量结构体”，所有字段都有 m 行，则输出是一个 m×n 表。
    如果输入是一个具有 n 个字段的 m×1 或 1×m 结构体数组，则输出是一个 m×n 表。
T = struct2table(S,Name,Value) 使用由一个或多个 Name,Value 参量指定的其他选项从一个结构体数组创建表。
    例如，可以指定要包括在表中的行名称。
%}
fieldnames(patients);
isfield(patients,{'name','abc'});
orderfields(patients,[2 1]);
struct2table(patients);

% 与元胞数组转换
% 元胞数组 → 结构体数组（需字段一致）
C = {struct('a',1), struct('a',2)};
S = [C{:}]; % 合并为结构体数组
% 结构体数组 → 元胞数组
S = struct('a', {1, 2});
C = num2cell(S); % 数组转换为元胞数组

%% 图形的保存与导出
%{
（1）Edit -> Copy Figure
（2）Toolbar -> Save
（3）print('-depsc','-tiff','-r300','picture1')
（4）File -> Export Setup
%}