# 清空工作区和命令行窗口
clear; 清空工作区（clear all）  
clc; 清空命令行窗口  
可直接在命令行窗口输入代码文件名（不带后缀）运行代码文件  
获取关键字的完整列表：命令行输入 iskeyword  
特殊变量：ans、pi、inf/-inf（1/0 = inf）


# 类型转换
```
                      num
                  //\     /\\
                 //         \\
                //      abs()\\         \
               //      int32()\\char()   } 都是与 “字符” 之间的转换（ASCII码）
              //       double()\\       /
     string()//double()         \\
            //str2num()          \\
           //str2double()         \\
          //              str2num()\\num2str() \ 都包含了 “str”，与 “字符数组” 相关
         //             str2double()\\         / （使得看起来像 “字符串”）
        //                           \\
      \//           char()            \\/
string --------------------------------> char
       <--------------------------------
                   string()
```


# 注意
## 几种括号
- 小括号：
    - 表示切片（取一部分），例如：`A(1,:)` 表示A的第 1 行；`A(start:end)` 表示A中从第一个到最后一个
    - 表示取元胞数组中元胞，例如：`C(i)` 返回仅包含**一个元胞**的 **“子元胞数组”**
- 中括号：
    - 表示创建矩阵，例如：`A = [1 2 3;4 5 2;3 2 7]` 表示创建了一个矩阵A；`C = [A,B]` 表示矩阵C由A和B拼接而成
- 大括号：
    - 表示创建元胞数组，例如：`C = {'文本', 123, [1 2; 3 4], magic(3)}`
    - 表示取元胞数组中元胞的内容，例如：`C{1}` 是元胞的 **“内容”**（如字符、数字等）

## 遍历顺序
多维矩阵的遍历是先将一层低维的遍历完，再沿着高维的方向遍历下一层低维
如：A[2,3,4,5]为四维数组（四维矩阵），遍历顺序为：A[1,1,1,1]，A[2,1,1,1]，A[1,2,1,1]，A[2,2,1,1]，...，A[2,3,4,1]，A[1,1,1,2]，...，A[2,3,4,5]

所以二维数组的遍历看起来是 **列优先的**。
因为 **行数** 写在 **列数** 前面，所以 **行** 成了 **列** 的 **低维**，
只有把一列的每行都遍历完，才能遍历下一列。
而要看起来 **行优先** 的话，就得把 **列数** 写在 **行数** 前面。

## 维度概念
可以说，多维矩阵 **不存在** **“行”** 的概念，只有 **第一维**、**第二维** 等概念，
就类似于 **(y,x,z)** 这样的坐标，第一维度为 **y轴**，第二维度为 **x轴**，第三维度为 **z轴**

按 **人脑** 的逻辑，对于`A(1,2,3)`，应该是：
- 先在**第一列**找到需要的**点**（就是第一维的一个点，零维），就是第一列的关注点，
- 再在**第一面**找到需要的**列**（就是第二维的一个列，一维），将第一列的关注点平移到该列，得到第一面的关注点，
- 再在**第一体**找到需要的**面**（就是第三维的一个面，二维），将第一面的关注点平移到该面，以此类推。

## 行优先与列优先
关键在于 **坐标中数字变化发生的方向**（可以认为坐标中最低维度总是行和列，且行号总是写在列号左边，即**列维度/y轴坐标**总是写在**行维度/x轴坐标左边**）
- **行优先**：遍历时，坐标中数字的变化 **从右向左** 发生（维度号 **从高到低**）
    - 如：A[1,1,1]，A[1,1,2]，A[1,2,1]，A[1,2,2]，...
    - 更适合想象为 **多维数组**，此时也可认为坐标中 **右侧是低维，左侧是高维**，**<font color='red'>维度向左扩张</font>**，类似数串，则也算是 **从低维到高维**
- **列优先**：遍历时，坐标中数字的变化 **从左向右** 发生（维度号 **从低到高**）
    - 如：A[1,1,1]，A[2,1,1]，A[1,2,1]，A[2,2,1]，...
    - 更适合想象为 **多维矩阵/张量**，**<font color='red'>维度向右扩张</font>**
- 按我们平时的思维遍历，看起来是 **“行优先”**，其实**本质**是 **“列优先”**，因为本质上，坐标数字变化是从 **低维到高维** 的，只不过 **最低维** 变成了 **列号（x轴）** 并且放到了 **第二个坐标位** （或者说前两个维度是 **行优先**，后面的维度都是 **列优先**）
    - 如：A[1,1,1]，A[1,2,1]，A[2,1,1]，A[2,2,1]，A[1,1,2]，...

也可通过判断数据结构 **<font color='red'>维度扩张的方向</font>**，一般都以该方向作为 **坐标中数字变化发生的方向**（也可认为是 **<font color='red'>维度升高的方向</font>**，此时可认为**坐标中数字变化**都是 **从低维到高维** 发生的，如果硬要从高到低变化，维度较大时靠人脑难以想象），从而决定是 **行优先** 还是 **列优先**，例如：
- 当数据结构是 **多维矩阵/张量** 时，**<font color='red'>维度向右扩张</font>**，采用 **列优先**（如 Matlab）
- 当数据结构是 **多维数组/z轴坐标写在左边的多维矩阵** 时，**<font color='red'>维度向左扩张</font>**，采用 **列优先**（如 NumPy，由于**维度向左扩张/升高**，所以NumPy的**第0维**是**最高维**）（NumPy中维度从0开始计数，而Matlab中维度从1开始计数）

**提问：** 为什么一般要以 **<font color='red'>维度扩张的方向</font>** 作为 **坐标中数字变化发生的方向**？
**回答：** 因为这样能使：以遍历时**坐标中数字变化发生的方向**作为 **从低维到高维的方向** 的同时，维度扩张时 **最低维度的内容保持不变**。因为一般数据结构的展现形式是固定的，当维度数增加时，一般是**以最低维作为基底往外扩展**。遍历时，如果使坐标中数字变化发生的方向为 **从低维到高维** ，且最低维度的内容保持不变，能够**方便人脑结合数据结构进行想象**（当然不这样也能想象，只是比较麻烦），因此，在这方面，**<font color='red'>行优先和列优先（NumPy和Matlab）是一样的，都是从低维向高维发生变化</font>**，只是维度扩展的方向不一样。

## 线性索引
当使用 **线性索引** 或 **`reshape`** 时，MATLAB 会临时将多维矩阵视为 **一维** 序列，顺序与 **遍历** 相同

## 矩阵索引
对于**多维**数组的**访问**和**删除**（**维度数**为 `n`，**索引值的维度数**为 `m`）
- `m = n`，**正常**访问，**要删除**的东西维度数 `d` 需满足 `d >= n-1`，否则会报错（**空赋值**只能具有**一个** **非冒号索引**）
- `1 < m < n`，会先将**多余的维度**在**第 `m` 维度** **“按遍历顺序”** **拼接**，使得 `n' = m`，然后访问或删除（**访问不会**修改原矩阵的**维度数**，**删除会**修改**维度数**）
    - “拼接过程” 其实就是 `reshape(A,dim_1,dim_2,...,dim_{m-1},dim_m*dim_{m+1}*...*dim_n)`
- `m = 1`，即**线性索引**，**“按遍历顺序”** 访问，**删除**时，矩阵会 “按遍历顺序” 变成一个 **“行向量”**，然后删除（比较**特殊**，不是变成 “列向量”）
    - 其实 **“遍历顺序”** 就是将 1 以上的维度拼接到第 1 维度，然后遍历

## 一维数组
MATLAB中，**一维数组**都是以 **1xN** 的**二维矩阵**形式存在的，**没有纯粹**的纯一维数组。
可使用 `size` 函数：`size([1 2 3])`返回 `[1,3]`（行向量），`size([1; 2; 3])`返回 `[3,1]`（列向量）

但 MATLAB 对向量的操作有**特殊优化**：
- 数学运算：行/列向量在加减、点乘等操作中会被自动识别为向量，**无需严格匹配维度**。
- 索引简化：单下标索引（`vec(i)`）对行/列向量通用，无需指定行或列。
- 可使用 `isrow`/`iscolumn` 判断方向

MATLAB中，很多**内部创建**或者**自动生成**的 **一维向量** 会创建成 **行向量**，即 **一维数组**，比如：
- 对矩阵用 **线性索引** **删除单个元素**时，矩阵会 **按遍历顺序** 变成一个 **行向量**，然后删除
- 使用 **未初始化** 的向量，会自动创建成 **行向量**
- 对矩阵尺寸的描述 `size` 通常是 **行向量**
- **<font color="red">注意</font>**：**聚集**类操作（如max、min等）生成的**一维向量** **<font color="red">不会</font>** 自动变成 **行向量**（与 python 中的 **NumPy** **<font color="red">不同</font>**）


## 标量
 MATLAB 中，标量（Scalar）在存储和操作时以 **1×1** **矩阵**的形式存在，但它们在语义和使用上具有特殊性。（MATLAB 中的**所有数据**（包括标量）**都是数组**）

 虽然标量是 1×1 矩阵，但 MATLAB 会**优化其存储**，不占用额外空间。

 尽管标量是 1×1 矩阵，但在运算时 MATLAB 会将其视为 **“单个值”**，**无需考虑矩阵维度规则**
- 与**矩阵运算**：标量可**自动广播**到匹配的矩阵维度。
- 逻辑简化：标量支持直接索引（尽管无意义，但语法合法）：

## 索引超出
矩阵索引时：
- **超出边界**时会**自动拓展**，用 **0 填充**，并永久**改变**矩阵大小
- **超出维度**时，该维度大小**默认为 1**，索引值**不为 1 时**会**改变**矩阵**维度**

使用矩阵时，可以**不用初始化**，会**自动创建**，未初始化的部分**用 0 填充**

## 矩阵拼接
`cat(dim, A, B, ...)`，其中 `dim` 表示 **在哪个维度拼接**
- dim = 1：在第一维度拼接，即拼接成列（y轴，纵向拼接）（即矩阵的第一个维度叠加）
- dim = 2：在第二维度拼接，即拼接成面（x轴，横向拼接）（即矩阵的第二个维度叠加）
- dim = 3：在第三维度拼接，即拼接成体（z轴，前后拼接）（即矩阵的第三个维度叠加）

## 广播原则（矩阵大小兼容）
**广播原则**：是一种允许**不同维度**的数组进行逐元素运算的机制。

它通过自动 **扩展** 较小数组的 **维度**，使其与较大数组的 **维度兼容**，从而无需显式复制数据即可完成运算。

**关键条件**：两个数组在 **每个维度** 上的大小**必须满足**以下之一：
- 相等（如 A 是 3×4，B 是 3×4）
- 其中一个**为 1**（如 A 是 3×4，B 是 1×4 或 3×1）（即矩阵没有该维度）
- 其中一个**维度不存在**（即较小数组的维度数较少，其实也就是该维度大小为 1）

广播的**步骤**：
- **对齐维度**：从**最后一个**维度开始**向前**匹配。
- **扩展**大小为 1 的维度：将较小数组的维度从 1 复制到与较大数组相同。
- 执行逐元素运算：如 +, .*, ./, max, min 等。

示例：
```matlab
A = [1; 2; 3];  % 3×1
B = [4 1 2];    % 1×3
min(A, B)       % 返回 3×3 矩阵：
                % [1 1 1; 2 1 2; 3 1 2]
```
其中，先将 A 扩充至 3x3，再将 B 扩充至 3x3

此外，`repmat` 函数（全称 Replicate Matrix）用于通过**重复复制**数组来创建更大的新数组。它通过沿指定维度堆叠输入数组的副本，实现数据的快速扩展，特别适用于需要**填充**或**广播数据**的场景。

## 多维操作
`vecdim` 为 `dim` 组成的向量，
- `dim` 是沿着 **某个维度**，即沿着**单个维度**的**一维直线**，即在该维度的直线内操作
- 而 `vecdim` 表示沿着 **多个维度**，即沿着**多维空间**，即在该多维空间内操作
- 一般 `vecdim` 可以写 `"all"`

**多维操作**必须是 **“集约的”**，如求和、求积、平均、最值等，**不能**是 **“线性的”**，如排序、拼接、差分、累加等

## 随机数流
MATLAB 系统中有一个 **随机数流**，其中包含了生成的**随机数序列**，每次生成随机数，都是**从上次结束的位置继续**向后取所需数量的随机数。

**设置**种子和算法会**重置**随机数流的内部**状态**，**取随机数**也会**从头开始**


**随机数流**是 MATLAB 中管理伪随机数生成器（PRNG）状态的对象，包含以下关键信息：
- **算法**（如 'mt19937ar'、'Threefry'）。
- **种子**（Seed）：初始化随机数序列的起始值。
- 内部**状态**：**生成下一个**随机数的当前**位置**。通过控制流的状态，可以精确复现或重置随机数序列。

MATLAB 的随机数是通过确定性算法生成的“伪随机数”，其特点为：
- 种子决定序列：**相同**种子和算法 → **完全相同**的随机数序列。
- 状态更新：每次调用 `rand`、`randi`、`randn` 等函数时，流的状态会更新。

每次**重新启动** MATLAB 会话时，随机数生成器均**复位**到**相同**的状态，这样使用生成随机数的命令会返回**相同的结果**

`rng` 函数控制**全局流**
- 全局流（Global Stream）：默认情况下，`rand`、`randi`、`randn` 共享同一个全局流。
- 独立流：可创建多个独立的流，用于并行计算或复杂模拟。

## 句柄
**句柄（Handle）** 是一种特殊的数据类型，用于**间接引用**和操作 MATLAB **对象**（如图形、函数、对象实例等）。它的**核心作用**是提供对底层对象的**访问接口**，从而实现对对象的控制、修改或传递。

**句柄** 就是一个对象的 **“实例接口”**，将对象的句柄值**赋值给**变量后，该变量就可以**代表**指定的对象，可以直接对其进行**操作**（如**查询、修改属性**）。
- 为什么**无法直接**对句柄进行操作？因为 MATLAB **无法识别**该语法（设计问题）
- 句柄变量是**对象**，**不要**尝试对句柄执行**转换**为数值、字符或其他类型的操作。
- 匿名函数返回的 **函数句柄** **无法**直接链式调用，必须**赋值给**变量后调用。

**句柄**可以认为类似于C++的 **指针** 或 **引用**

## 绘图
MATLAB 绘图是在画布上绘图，会先将画布**清空**（覆盖）。

**图形标注和控制** **本质上** 也是**绘图**，但是**不会清空**画布，因此可以在已经画好的图形上标注和控制。但是再次绘图就会清空画布，所以图形标注**只能标注和控制** **上一次** 绘制的图形，而**新绘制**的图形会**清空**图形标注和控制

## 图窗（图形窗口）
**图窗**就是 **“总画布”**（Figure 对象），上面可能有多个 **“子图窗”**，即多个 **“子绘图区域”**（Axes 对象）。

在 MATLAB 中，**Figure 对象（图形窗口对象）** 是所有可视化元素的**顶级容器**，它代表一个**独立**的**图形窗口**，用于承载和管理 Axes（坐标轴）、菜单栏、工具栏、颜色条、图例 等组件。

在 MATLAB 中，**Axes 对象（坐标轴对象）** 是图形窗口中用于绘制数据的核心容器，它定义了数据的**可视化区域**，并控制坐标轴、标签、刻度、标题等元素的显示方式。

**Figure 对象**的**作用**：
- **容器**功能：作为 Axes、UI 控件（如按钮、滑块）的**父级容器**。
- **窗口**管理：**控制图形窗口**的尺寸、位置、标题、背景色等。
- 交互支持：响应鼠标点击、键盘事件（通过回调函数）。
- **多图**支持：允许同时打开**多个图形窗口**（每个窗口是一个独立的 Figure）。

**Axes 对象**的**主要功能**包括：
- 定义**绘图区域**：确定数据在图形窗口中的**显示范围**。
- 管理**坐标轴**：设置 X/Y/Z 轴的刻度、标签、范围等。
- 控制**图形元素**：管理线条、曲面、文本、图例等子对象的属性和位置。
- 调整**视角和投影**（3D 图形）：例如 view(3) 可切换为三维视图。

## 元胞数组
可以包含**任意类型**元素的**数组**，可以是**多维的**

MATLAB 中，**元胞数组**可以认为是**更高层次**的**数组**，能包含任意元素。（因此普通数组能干的事，元胞数组基本都能干）。**普通数组**可以看作是 **“单个值”**（因为MATLAB中向量或矩阵就是一个值），而元素个数大于一的**元胞数组不能**看作是 **“单个值”**，只能看做 **“数组”**（**除非**元胞数组**作为元胞**的内容，即**嵌套**元胞数组）。因此，普通数组的元素 **不能** 直接是元胞数组。

类似于 C++ 的 **“结构体”** 的**实例**，但是没有 **“字段”**，而且**不一定**是**线性**的，可以是 **“多维数组”**

**“元胞”** 是元胞数组的**元素**，可以是任意类型（包括元胞数组），而 **“元胞”** **不是**数据类型，**“元胞数组” 才是**数据类型
- **本质**：**元胞**是一个 **“容器”**，可以存储任意类型的数据（如数字、字符串、矩阵、结构体等），一般说 **“元胞”**，就是指 **“元胞内容”**，**“元胞类型”** 指 **“元胞内容的类型”**，**“空元胞[]”** 指 **“内容为空[]的元胞”**
- **本质**：**元胞数组**是由多个元胞组成的数组，每个元胞可存储不同类型、大小的数据。

对于元胞数组 `C`：
- `C(i)` 返回仅包含**一个元胞**的 **“子元胞数组”**（仍是 `cell` 类型，但是**不能**写`C(2){1}`，无法识别，无法链式调用）。
- `C{1}` 是元胞的 **“内容”**（如字符、数字等），其数据类型取决于存储的内容。
- **元胞**本身**没有独立**的**数据类型标识**（如 `class(C{1}`) 返回的是**内容的类型**，而非 `"cell"`）。
- **元胞数组**是 MATLAB 的一种**数据类型**，属于**复合类型**（类似结构体、表格）。
- 类型标识：通过 `class(C)` 会返回 `'cell'`，表明变量 C 是**元胞数组类型**。

修改元胞数组 `C` 的**内容**：
- 使用`{}`赋值：直接对**内容**赋值
    - `C{i} = value;` 
- 使用`()`赋值：对**子元胞数组**赋值，由于 `C(i)` 返回的是仅包含一个元胞的**子元胞数组**，所以赋的值也得是**元胞数组**，且大小为 1
    - `C(i) = {value};`

## 结构体
类似于 Python 的 **“字典”**，也类似于 C++ 的 **“结构体”** 的**实例**

**结构体数组** 可以看作元素都是**同种结构体**的**普通数组**，因此普通数组能干的事，结构体数组基本上都能干。

**结构体数组** 也可以看作是**字段对应的数值**都是**普通数组**的**结构体**，因此也可以作为一种**数据类型**，也可以结构体的字段的数据类型。

**结构体数组**的创建需要**非标量元胞数组**，而**普通数组**仅可作为字段的**一个数值**，也体现了[元胞数组和普通数组的区别](#元胞数组)

**结构体数组**的创建：
- `s = struct(field1,value1,...,fieldN,valueN)`
- 如果 `value` 的所有输入**都不是** **元胞数组**，**或者** `value` 中作为**元胞数组**的所有输入**都是标量**（仅有**一个元素**），则 `s` 是 **“标量结构体”**。
- 如果任一 `value` 输入是**非标量元胞数组**，则 `s` 具有与该元胞数组相同的维度。
    - 此外，如果两个或多个 `value` 输入是非标量元胞数组，则它们必须都具有 **“相同的维度”**。
    - 若想让字段的**值为元胞数组**，需要**嵌套**在外层元胞数组内，即`{{...}}`
- 对于类型为标量元胞数组或任何其他数据类型的数组的任何 `value`，`struct` 将 `value` 的内容插入 `s` 的所有元素的相关字段中。（类似于**广播**）


# 语法注意
## for 循环
```matlab
for 循环变量 = 向量或者矩阵
    循环体
end
```
- 循环变量：会在每次循环迭代中从向量或矩阵中取出 **一列** 的值。
- 类似于 **C++** 和 **Java** 中基于范围的循环：`for(int i:array){}`
- 类似于 **Python** 中基于范围的循环：`for num in nums:...`
- 类似于 **C++** 中的 `for_each()`：`std::for_each(vec.begin(), vec.end(), print);`
- 类似于 **Java** 中的 `forEach()`：`集合.forEach(操作);`

## 函数
定义完的函数保存为 **同函数名** 的 **m文件**，放置在 Matlab 的当前路径之下
```matlab
function[输出形参表：output1,...,outputn] = 函数名(输入形参表：input1,...inputn)
注释说明部分
函数体代码部分
end
% 其中，输出形参为单个时，可省略 []；
% 无输出时，可省略 []=；
% 无输入时，可省略 ()。
% 无论定义时是否省略 ()，调用时若用函数名直接调用，均可不加 ()
% 函数句柄例外：通过函数句柄 @ 调用时，必须加 ()
function main
    disp('No parentheses');
end
main;   % 合法
main(); % 也合法
f = @main;
f();  % 必须加 ()
```
在同一 .m 文件中定义多个函数，**仅主函数**可被外部调用，其他函数称为 **局部函数**（或 子函数）

函数体里面也可以定义函数（**嵌套函数**），嵌套函数在外层函数体内的 **位置可以任意**，不影响使用

嵌套函数只能被外层函数以及其他位于**同一外层函数体内**的嵌套函数调用

在调用函数时，Matlab 用两个永久变量 **`nargin`** 和 **`nargout`** 分别记录调用该函数时的**输入实参**和**输出实参**的**个数**

## 匿名函数
匿名函数是**不存储**在程序文件中，数据类型是 `function_handle` 的变量相关的函数

MATLAB **不支持** 直接**链式**调用（函数句柄 `function_handle` 不是可立即调用的数值）
```matlab
f = @(input1, input2, ...) expression;
% expression：函数的返回值（只能是单个表达式，但可将多个表达式合并为一个逗号分隔的表达式组，最后一个表达式的结果作为返回值）。
% 定义两数之和
add = @(a, b) a + b;
disp(add(2, 4));  % 输出 6

% 将多个表达式合并为一个逗号分隔的表达式组，最后一个表达式的结果作为返回值：
f = @(x) (disp(['输入: ', num2str(x)]), x^2 + 1);
f(3);  
% 输出: 输入: 3
% 返回: 10
```

类似于 **C++** 中：
```C++
// 函数指针
返回类型 (*指针名)(参数类型1, 参数类型2, ...);
int (*funcPtr)(int, int) = add;

// Lambda 函数
[捕获列表](参数列表) -> 返回类型 { 函数体 }
auto multiply = [](int a, int b) -> int {
        return a * b;
    };
int result = multiply(3, 4);
// 注意：值捕获，是在定义函数时就捕获，不会受后续任何影响
```
类似于 **Java** 中：
```Java
// Lambda 表达式
(参数列表) -> { 函数体 }
(String s1, String s2) -> {
    return s1.compareTo(s2);
}
/*
Lambda 表达式的简化
参数类型推断：可以省略参数类型，编译器会自动推断。
单参数简化：如果只有一个参数，可以省略括号。
单行代码简化：如果函数体只有一行代码，可以省略大括号和 return 关键字。
*/
Runnable runnable2 = () -> System.out.println("Hello from Lambda!");
```
类似于 **Python** 中：
```python
# lambda 表达式
lambda arguments: expression
# arguments：函数的参数（可以多个，用逗号分隔）。
# expression：函数的返回值（只能是单个表达式，不能包含语句如 if-else 块，但可用三元表达式）。
is_even = lambda x: "Even" if x % 2 == 0 else "Odd"
```